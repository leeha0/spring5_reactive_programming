# 스트림의 새로운 표준 - 리액티브 스트림
### 모두를 위하나 반응성
#### API 불일치
* 자바 코어, RxJava, Spring 등 과도하게 많은 선택지로 인한 시스템 복잡성 향상   
    → 예를들어, ListenableFuture, CompletionStage는 직접적인 통합을 제공하지 않으므로, 개발자가 집접 통합해야 한다
* 일관된 API 개발을 위한 표준화된 방법이 없음
* RxJava를 지원하는 추가 모듈의 비표준화 문제
    * RxJava 1.x 버전 비호환성
    * RxJava 커스터마이징 비표준화
    
#### 풀 방식과 푸시 방식
* 초기에는 소스에서 구독자에게 푸시되는 방법을 사용
* 풀 방식
    * 처리 시간 대부분 유휴 상태에서 낭비됨
    * 네트워크 작업으로 인해 전체 처리 성능 저하
    * 사전에 데이터를 생성할 수 없어 대기 상태 
* 풀 방식과 배치 처리 결합
    * 여전히 처리 시간동안 유휴 상태에서 낭비됨
* 푸시 방식
    * 한번만 데이터를 요청하기 때문에 대기 상태가 한번만 존재
    * 소스 데이터를 비동기적으로 푸시
```java
public Observable<Item> list(int count) {
    return dbClient.getStreamOfItems()
                    .filter(item -> isValid(item)) // 1급 객체
                    .take(count);
}
```

#### 흐름 제어
* 푸시 모델을 통해 요청하는 횟수를 최소화해 전체 처리 시간을 최적화함
* 푸시 모델의 기술적 한계
    * 메시지 기반 통신의 본질은 요청에 응답
    * 비동기적이며 잠재적으로 무한한 메시지 스트림을 수신할 수 있다고 가정
    
##### 느린 프로듀서와 빠른 컨슈머
* 프로듀서 수를 늘려 컨슈머의 부담 가중
* 푸시 모델에서 동적으로 처리량을 증가시키는 것은 불가능

##### 빠른 프로듀서와 느린 컨슈머
* 부하를 받는 컴포넌트의 치명적 오류 발생
* 큐를 통한 배압 관리

##### 무제한 큐
* 큐의 사이즈를 제한하지 않음
* 모든 원소가 먼저 큐에 저장
* 모든 메시지 전달에 대한 확신 가능

##### 크기가 제한된 드롭 큐
* 큐가 가득 차면 신규 유입된 메시지를 무시
* 자원의 한계를 고려하여 큐의 용량 구성
* 메시지의 중요성이 낮을 때 일반적으로 사용

##### 크기가 제한된 블로킹 큐
* 제한에 도달하면 메시지 유입 차잔
* 시스템의 비동기 동작을 모두 무효화

#### 해결책
* 2013년 리액티브 스트림 표준 발표

> 일급 컬렉션  
> 일급 객체

### 리액티브 스트림의 기본 스펙
* Publisher, Subscriber, Subscription, Processor 네 가지 기본 인터페이스 정의
* org.reactivestreams 패키지
* 하이브리드 푸시-풀 모델, 푸시 모델, 풀 모델

#### 리액티브 스트림 동작해 보기
* subscribe = 뉴스 구독
* onSubscribe = 뉴스 구독 축하 편지
* request = 고객이 읽을 수 있는 만큼 뉴스 요청
* onNext = 고객이 뉴스를 읽을 수 있음
* eventuallyReadDigests = 고객이 받은 편지함을 확인하지 않은 경우 블랙리스트 처리

##### Processor 개념의 소개
* Publisher와 Subscriber의 혼합 형태
* Publisher와 Subscriber 사이에 처리 단계 추가
* 스트리밍 파이프라인 역할을 할 수 있고, 비즈니스 로직 흐름을 더 쉽게 이해 가능

#### 리액티브 스트림 기술 호환성 키트(TCK)
* 동작을 검증하고 반응 라이브러리를 표준화해 서로 호환하는지 확인하는 공통 도구

#### JDK 9
* 리액티브 스트림 스펙을 JDK 9에 추가하자는 제안
* 스트림 API 풀링 기반
* java.util.concurrent.Flow
* org.reactivestreams.*  
    → 호환가능한 메서드 제공
 
### 리액티브 스트림을 활용한 비동기 및 병렬 처리
* Publisher가 생성하고 Subscriber가 소비한 모든 신호는 논블로킹이어야 한다  
    → 프로세서의 한 노드 또는 한 개의 코어를 효율적으로 활용 가능  
    → 병렬처리 필요?  
* on*** 메서드의 호출은 `스레드 안정성을 보장하는 방식으로 신호를 보내야 하며, 다중 스레드에서 수행되는 경우 외부적인 동기화를 사용해야 한다`고 명시  
    → 직렬화되고 순차적인인 호출  
    → 자원을 효과적으로 쓰려면 ?    
* 스트림 처리 파이프
    * 데이터 소스 및 목적징와 함께 몇 가지 처리 또는 변환 단계를 포함
    * 각 단계에 메시지를 비동기적으로 전달
    * 두 개의 독립적인 스레드 간에 처리를 분할함으로 처리 단계 사이에 비동기 경계를 설정
    * 큐와 같은 데이터 구조 활용 가능  
    → 병렬화 달성  
* 비동기 처리시 어떤 스레드 영역에서 처리 흐름이 포함되어야 하는가?
    * 처리 흐름이 소스 리소스에 연결되어 소스와 동일한 경계 내에서 발생
    * 처리 흐름이 목적지 또는 컨슈머 스레드에 연결되는 경우 (메시지 생산이 CPU를 많이 사용하는 경우)
    * 모든 처리를 별도의 스레드에서 작업 (메시지 생산과 소비가 모두 CPU를 많이 사용하는 경우)  
    → 즉 스레드가 사용하는 자원에 따라 설계  