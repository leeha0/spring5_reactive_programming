# 스프링을 이용한 리액티브 프로그래밍 - 기본 개념

### 리액티브를 위한 스프링 프레임워크의 초기 해법
* 콜백
* Future
* CompletableFuture (Java8+)
* ListenableFuture (Spring4+)

#### 관찰자(Observer) 패턴
* 이벤트를 발생시키는 역할과 이벤트를 수신하는 역할 두 가지 핵심 요소
* 주체가 상태의 변경을 관찰자에게 알림
* 런타임 시점에 객체 사이에 일대다 의존성 등록
* 상호 작용하게 하면서도 응용 프로그램 사이의 결합도를 낮춤

#### 관찰자 패턴 사용 예
* 관찰자가 많을 경우 스레드 할당 또는 스레드 풀을 사용해 메시지 병렬 처리 가능
* 의도하지 않은 장애가 발생할 수 있음
* 각 스레드는 자바에서 약 1MB를 소비

> 스파이 패턴(Spy pattern)  
> : 단위 테스트시 의존성 없이 테스트를 하기 위해 의존 객체를 다른 코드로 대체하는 패턴

> 라이브니스(liveness)  
> : 시스템에서 동시에 실행되는 구성 요소(프로세스)가 임계 영역(동시에 실행될 수 없는 프로그램의 일부분)에 접근할때 교대로 전환해야하는 상황에도 시스템이 진행하도록 하는 동시성 성질
> * deadlock, livelock, starvation

#### @EventListener를 사용한 발행-구독 패턴
* 스프링 프레임워크에는 이벤트 처리를 위한 @EventListener 애노테이션, 이벤트 발행을 위한 ApplicationEventPublisher 클래스 제공
* 발행-구독 패턴
    * 게시자와 구독자 간의 간접적인 이벤트 채널(메시지 브러커, 이벤트 버스) 계층이 존재
    * 게시자와 구독자는 서로를 알 필요가 없음
* 이벤트 채널을 통해 필터링 작업을 할 수 있음
* 이벤트 채널 관련 랑라브러리: MBassador, Guava

> 토픽 기반 라우팅 vs 내용 기반 라우팅  
> 토픽 기반 라우팅: 메시지 유형을 통한 라우팅으로 모든 메시지를 라우팅 
> 내용 기반 라우팅: 스프링 표현 언어(SpEL)를 통해 조건 속성을 지정하여 라우팅 
    
#### @EventListener를 활용한 응용 프로그램 개발
* 리액티브 디자인에 따라 고전적인 폴링 모델을 사용할 수 없음
* 리액티브 디자인을 따르는 방법
    * 서버 사이드: 웹소켓(WebSocket) 및 SEE(Server-Sent Events) 프로토콜을 통해 비동기 메시지 전달 (`Push 모델`)
    * 클라이언트 사이드: EventSource 자바스크립트 API를 통해 이벤트 스트림을 수신

#### 솔루션에 대한 평가
* 고부하 및 고성능 시나리오를 위한 구현이 아님
* 스프링 프레임워크의 내부 메커니즘을 사용하여 안정성 위협
* 단위테스트의 어려움
* @EventListener 사용하여 종료 및 오류에 대한 처리가 어려움
* 스레드 풀을 이용한 비동기적 브로드캐스팅으로 진정한 리액티브 접근과는 차이가 있음
* 클라이언트 존재 여부와 상관없이 이벤트 발생

### 리액티브 프레임워크 RxJava
* RxJava 라이브러리는 Reactive Extensions(ReactiveX)의 구현체이다
* Reactive Extensions
    * 동기식 또는 비동기식 스트림과 관계없이 명령형 언어를 이용한 데이터 스트림을 조작하는 도구
    * 관찰자 패턴, 반복자 패턴, 함수형 프로그래밍의 특징을 갖음

### 관찰자 + 반복자 = 리액티브 스트림
* 데이터 스트림의 끝을 알리기 위해 반복자 사용
* 반복자 패턴의 next 메서드를 호출하는 대신 onNext로 새로운 값이 통지
* 반복자 패턴의 hasNext 메서드를 호출하는 대신 onComplete, onError로 완료 및 에러 통지
* onNext, onComplete, onError 메서드 추가

### 스트림의 생산과 소비
* 문자, 배열, 컬렉션, Callable, Future 등 인스턴스 생성을 위한 다양한 유연성 제공

### 비동기 시퀀스 생성하기
* 주기적으로 비동기 이벤트 시퀀스를 생성할 수 있음
    * Thread.sleep
    * CountDownLatch
    
### 스트림 변환과 마블 다이어그램
* 마블다이어그램: 스트림 변환을 시각적으로 표현
* Map 연산자: 원소를 하나씩 변환하여 재발행
* Filter 연산자: 조건부 테스트를 성공적으로 통과한 원소만 재발행
* Count 연산자: 입력 스트림의 개수를 발행
* Zip 연산자: 두 개의 병렬 스트림 값을 결합
* Observable.Transformer<T, R>: 사용자 지정 연산자 작성 가능

### RxJava 사용시 전제 조건 및 이점
* 구독자가 관찰 가능한 스트림에 가입한 후, 비동기적으로 이벤트를 생성해 프로세스를 시작한다는 핵심 개념
* 프로듀서-컨슈머 관계를 해지할 수 있는 채널 존재
* 융통성, 이벤트양 제어, CPU 사용량을 줄임
* 스레드 실행 관리시 객체를 변경(mutate) 시키는 것은 안전하지 않아 불변 객체를 사용해야 하는 제약

> 리액티브 프로그래밍의 성공적 사용을 위해 1급 객체가 필요하다 = 람다(Java8+)
> * 변수나 데이타에 할당 할 수 있어야 한다.(ex, 함수를 변수에 할당)
> * 객체의 인자로 넘길 수 있어야 한다. (ex, 함수를 인자로 넘김)
> * 객체의 리턴값으로 리턴 할수 있어야 한다. (ex, 함수를 반환)

#### RxJava를 이용해 애플리케이션 다시 만들기
* REST 컨트롤러는 구독이 해지된 인스턴스를 관리하지 않고, 동기화를 신경쓰지 않음
* 이벤트 버스를 사용하지 않음으로 이식성이 높음
* 스프링 컨텍스트가 없어도 테스트가 가능

#### 애플리케이션 설정하기
* 발행-구독 접근법과 스프링 @EventListener 애노테이션을 사용하지 않음
* Async에 대한 의존성 제거
* Executor에 대한 설정이 제거되었으며, 필요하다면 RxJava에서 제공하는 Scheduler 사용
* 아무도 구독하지 않을 경우 발생하는 오버 헤드 제거 → `능동적 구독 실현`

### 리액티브 라이브러리의 간략한 역사 
* 2005 마이크로소프트에서 시작
* 2007 Rx 라이브러리 탄생
* 2009 Rx.NET 공개   
* 2012 Rx.NET 오픈소스 공개 
* 2013 넷플릭스에서 RxJava 라이브러리 오픈소스 공개 
* 오늘날 Couchbase, MongoDB, NoSQL, Android, iOS....