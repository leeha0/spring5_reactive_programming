# 스프링을 이용한 리액티브 프로그래밍 - 기본 개념

### 리액티브를 위한 스프링 프레임워크의 초기 해법
* 콜백
* Future
* CompletableFuture
* ListenableFuture

### 관찰자(Observer) 패턴
* 이벤트를 발생시키는 역할과 이벤트를 수신하는 역할 두 가지 핵심 요소
* 상태의 변경을 관찰자에게 알림
* MVC(Model-View-Controller) 패턴에서도 중요한 역할

### 관찰자 패턴 사용 예
* 관찰자가 많을 경우 스레드 할당 또는 스레드 풀을 사용해 메시지 병렬 처리 가능

> 스파이 패턴(Spy pattern)  
> : 단위 테스트시 의존성 없이 테스트를 하기 위해 의존 객체를 다른 코드로 대체하는 패턴

> 라이브니스(liveness)  
> : 시스템에서 동시에 실행되는 구성 요소(프로세스)가 임계 영역(동시에 실행될 수 없는 프로그램의 일부분)에 접근할때 교대로 전환해야하는 상황에도 시스템이 진행하도록 하는 동시성 성질

### @EventListener를 사용한 발행-구독 패턴
* 스프링 프레임워크에는 이벤트 처리를 위한 @EventListener 애노테이션, 이벤트 발행을 위한 ApplicationEventPublisher 클래스 제공
* 발행-구독 패턴
    * 게시자와 구독자 간의 간접적인 이벤트 채널(메시지 브러커, 이벤트 버스) 계층이 존재
    * 게시자와 구독자는 서로를 알 필요가 없음
    
### @EventListener를 활용한 응용 프로그램 개발
* 웹소켓(WebSocket) 및 SEE(Server-Sent Events) 프로토콜을 통해 메시지 전달

### 스프링 웹 MVC를 이용한 비동기 HTTP 통신
* @Controller는 단일 타입 T 이외에도 Callable<T>, DeferredResult<T> 반환 가능

### SSE 엔드포인트 노출
* SseEmitter: SSE 이벤트를 보내기 위한 클래스

### 솔루션에 대한 평가
* 고부하 및 고성능 시나리오를 위한 구현이 아님
* 스프링 프레임워크의 내부 메커니즘을 사용하여 안정성 위협
* 단위테스트의 어려움
* @EventListener 사용하여 종료 및 오류에 대한 처리가 어려움
* 스레드 풀을 이용한 비동기적 브로드캐스팅으로 진정한 리액티브 접근과는 차이가 있음
* 클라이언트 존재 여부와 상관없이 이벤트 발생

### 리액티브 프레임워크 RxJava
* RxJava 라이브러리는 Reactive Extensions(ReactiveX)의 구현체이다
* Reactive Extensions
    * 동기식 또는 비동기식 스트림과 관계없이 명령형 언어를 이용한 데이터 스트림을 조작하는 도구
    * 관찰자 패턴, 반복자 패턴, 함수형 프로그래밍의 특징을 갖음

### 관찰자 + 반복자 = 리액티브 스트림
* 반복자 패턴의 next 메서드를 호출하는 대신 onNext로 새로운 값이 통지
* 반복자 패턴의 hasNext 메서드를 호출하는 대신 onComplete, onError로 완료 및 에러 통지
* onNext, onComplete, onError 메서드 추가

### 스트림의 생산과 소비
* 문자, 배열, 컬렉션, Callable, Future 등 인스턴스 생성을 위한 다양한 유연성 제공

### 비동기 시퀀스 생성하기
* 주기적으로 비동기 이벤트 시퀀스를 생성할 수 있음
* 관찰자와 구독자 간의 협력을 제어하기위해 Subscription을 제공

### 스트림 변환과 마블 다이어그램
* 마블다이어그램: 스트림 변환을 시각적으로 표현
* Map 연산자: 원소를 하나씩 변환하여 재발행
* Filter 연산자: 조건부 테스트를 성공적으로 통과한 원소만 재발행
* Count 연산자: 입력 스트림의 개수를 발행
* Zip 연산자: 두 개의 병렬 스트림 값을 결합
* Observable.Transformer<T, R>: 사용자 지정 연산자 작성 가능

### RxJava 사용시 전제 조건 및 이점
* 구독자가 관찰 가능한 스트림에 가입한 후, 비동기적으로 이벤트를 생성해 프로세스를 시작한다는 핵심 개념
* 프로듀서-컨슈머 관계를 해지할 수 있는 채널 존재
* 융통성, 이벤트양 제어, CPU 사용량을 줄임
* 응답성 확보 
* 스레드 실행 관리시 객체를 변경(mutate) 시키는 것은 안전하지 않아 불변 객체를 사용해야 하는 제약

> 1급 객체   
> * 변수나 데이타에 할당 할 수 있어야 한다.(ex, 함수를 변수에 할당)
> * 객체의 인자로 넘길 수 있어야 한다. (ex, 함수를 인자로 넘김)
> * 객체의 리턴값으로 리턴 할수 있어야 한다. (ex, 함수를 반환)

### RxJava를 이용해 애플리케이션 다시 만들기
* REST 컨트롤러는 구독이 해지된 인스턴스를 관리하지 않고, 동기화를 신경쓰지 않음
* 이벤트 버스를 사용하지 않음으로 이식성이 높음
* 스프링 컨텍스트가 없어도 테스트가 가능

### 애플리케이션 설정하기
* 발행-구독 접근법과 스프링 @EventListener 애노테이션을 사용하지 않음
* Async에 대한 의존성 제거
* Executor에 대한 설정이 제거되었으며, 필요하다면 RxJava에서 제공하는 Scheduler 사용
* 아무도 구독하지 않을 경우 발생하는 오버 헤드 제거
* 능동적 구독 실현

### 리액티브 라이브러리의 간략한 역사 
* 마이크로소프트에서 시작하여 2007 Rx 라이브러리 탄생, 2012 Rx.NET 공개
* 넷플릭스에서 Rx.NET을 자바 플랫폼으로 이식하여 2013 RxJava 탄생