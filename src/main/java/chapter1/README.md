# 왜 리액티브 스프링인가?
### 왜 리액티브인가?
* 프로그래밍 모델의 한 종류를 의미
* 응답 성능에 영향을 미치는 모든 변화에 대응 가능한 시스템 개발을 위한 모델

#### 응답성 확보를 위한 요소
* 탄력성(elasticity)
    * 사용자 요청량에 따라 시스템이 자동으로 확장 및 축소
    * 평균 지연 시간에 영향 없이 응답성을 유지하는 것 
    * 탄력성이 없다면 사용자 요청 증가에 따라 평균 지연 시간이 증가하며 전체 응답 성능에 영향을 미침
       
> 암달의 법칙(Amdahl's Law)과 건터(Gunther)의 보편적 확장성 모델(Universal Scalability Model)  
> : 탄력성은 수평적/수직적으로 확장하며 달성할 수 있다. 하지만, 분산 시스템에서는 병목 또는 동기화 지점에 대해 확장하는 것으로 그치는데 이러한 문제를 일컬음
   
* 복원력
    * 시스템 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보하여 달성
        * 사용자 주문 접수, 결재 서비스 → 결재 서비스 장애시 주문 접수건에 대해 재시도
        * 댓글 서비스, 장바구니 확인, 결제 서비스 → 댓글 서비스 장애시 타 서비스는 영향 없이 동작

* 탄력성 그리고 복원력
    * 탄력성과 복원력은 밀접하게 결합되어 있어 두 가지 모두 충족해야 시스템 응답성 달성
        * 시스템을 확장하여 다수의 복제본을 갖을 경우, 하나의 노드에서 장애가 발생해도 시스템 영향 최소화
       
### 메시지 기반 통신
* 리소스 활용도를 높이려면 비동기 논블로킹(asynchronous and nonblocking) 방식의 모델 사용
* 분산 시스템에서 서비스 간에 통신시 효율적으로 자원을 사용하기 위해 메시지 기반(message-driven) 통신 원칙을 따름
    * 메시지 브로커(message broker): 메시지 대기열을 모니터링하고 시스템 부하 관리 및 탄력성을 제어

#### 리액티브 기본원칙
* 탄력성과 복원력을 바탕으로 응답성을 확보 
* 메시지 기반을 통해 구현
* 구성 요소가 독립적이고 적절하게 격리돼 있기 때문에 유지 보수 및 확장이 용이

### 반응성에 대한 유스케이스
* 웹 사이트, 대규모 엔터프라이즈 솔루션, 고속 스트리밍, 빅데이터 시스템
* 분산 시스템 구축에 리액티브 원리를 적용할 수 있기 때문에 적용 영역에 제한되지 않음

> 스트리밍(streaming) 아키텍처
> * 데이터 처리 및 변환 흐름을 만드는 것으로 짧은 지연 시간과 높은 처리량이 특징
> * 리액티브 기본원칙에 의존한다 
> * 배압을 적용해야 한다 
>   : 처리 단계 사이의 작업 부하를 관리하는 정교한 메커니즘으로 자신의 부하가 다른 프로세스로 파급되는 것을 방지
> * 메시지 브로커를 사용할 수 있다
>   : 메시지 기반 통신을 사용해 작업 부하 관리 효율적 수행, 메시지를 내부 저장소에 보관하고 요청시 전송

### 왜 리액티브 스프링인가? 
* Akka: Scala에서 리액티브 시스템을 구축하기 위한 프레임워크 
* Vert.x: Node.js를 대체하기 위해 논블로킹 및 이벤트 기반으로 설계된 프레임워크
* 리액티브 시스템 구축을 위한 프레임워크가 있지만 여전히 스프링 프레임워크가 강력하게 사용된다. 하지만, 리액티브 시스템을 구축하는데 몇 가지 제약 사항이 존재한다
  
### 서비스 레벨에서의 반응성
> 스프링 클라우드(Spring Cloud)  
> : 분산 시스템 구축을 단순화 하는 프레임워크로 스프링에서 리액티브 시스템 구축하는데 적합하도록 지원 

* 구성 요소 수준에서 리액티브 설계 및 구현을 제공하는 것이 중요!
* 명령형 프로그래밍(imperative programming)
    * 동기적으로 수행하며, 각 컴포넌트가 강결합되어 요청을 처리하는 동안 다른 작업을 실행할 수 없는 상태 
* 콜백 처리 방법
    * 컴포넌트 간의 통신을 콜백 함수를 통해 구현
    * 동기 & 비동기 구현 가능
    * 공유 데이터 변경 및 콜백 지옥에 대한 멀티 스레딩 기본 지식 필요 
* Future 처리 방법
    * java.util.concurrent.Future
    * 결과값 반환 지연
    * 콜백 지옥을 피할 수 있음
    * 멀티 스레드의 복잡성을 숨길 수 있음 
* CompletableFuture
    * 반환 결과를 기능적 선언 방식으로 처리
    * 함수형 스타일 또는 선언형 스타일로 코드를 작성
    * 깔끔한 코드 작성 가능하며 비동기적으로 결과 처리 가능 
    * 스프링4 MVC에서 지원하지 않음
* ListenableFuture
    * 스프링4 MVC에서 CompletableFuture 역할을 수행 
    * 구형 자바 버전과의 호환성 목료로 제공
    * 깔끔한 코드 작성이 불가능하며 멀티 스레딩에 대해 추가적인 고려가 필요
        * 블로킹 네트워크호출은 별도의 스레드로 래핑
        * 스프링 MVC의 모든 구현체는 요청에 대해 별도의 스레드를 할당하는 서블릿(Servlet) API 사용 
    * 컨텍스트 스위칭(context switching)으로 인한 비효율적으로 동작 가능성
        * 스레드 시작시 레지스터, 메모리 맵 등의 요소에 대한 저장 및 로딩시 추가적인 비용 발생 
        * CPU 수보다 많은 수의 스레드를 활성화 시키면 여러 스레드가 CPU를 공유하며 발생하는 컨텍스트 스위칭 비용으로인해 결과적으로 성능 저하 발생

> 블로킹(Blocking) vs 논블로킹(Non-Blocking) 
> * 호출되는 함수가 즉시 결과(제어권)를 리턴하는지 여부에 따라 구분
> 
> 블로킹: 호출된 함수의 수행이 끝날 때까지 제어권을 갖으며 이때 호출한 함수가 다른 작업을 수행할 수 없는 것을 의미
> 논블로킹: 호출된 함수가 호출 즉시 제어권을 넘겨주고, 호출한 함수가 다른 작업을 수행할 수 있도록 하는 것을 의미
> 
> 동기(Synchronous) vs 비동기(Asynchronous)
> * 호출되는 함수의 작업 완료 여부를 누가 신경쓰느냐에 따라 구분
>
> 동기: 함수 호출시 호출된 함수의 작업 완료를 기다린다. 호출한 함수는 작업 완료 여부를 신경쓰는 경우
> 비동기: 함수 호출시 콜백을 전달하며, 호출된 함수는 작업이 완료되면 콜백을 실행한다. 호출한 함수는 작업 완료 여부를 신경쓰지 않는 경우

